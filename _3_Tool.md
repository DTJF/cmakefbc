Tool cmakefbc_deps  {#PagCmakeFbDeps}
==================
\tableofcontents

*cmakefbc_deps* is a tool that

- is designed to be used with \CMake extension \Proj (this package),
- to scan dependencies in \FB source code, and
- generate a \CMake include file to declare and up-date this dependencies in a project.

Find build and install instructions in chapter \ref PagInstall.


# Usage  {#SecUsage}

Usually this tool doesn't get called directly by the user. Instead it
gets called by the \CMake macro \Tar or by the function \Bas.

The calling signature is

~~~{.txt}
./cmakefbc_deps <output> <input1> [<input2> [<input3> [...]]]
~~~

At least two arguments are required:

- The name of the output file (gets overriden without warning, if present) and
- a FB source file name to scan.

All further arguments are treated as FB source file names to scan (read
only access).


# Error Messages  {#SecErrors}

In case of an error the tool ends with return value 1 and outputs one
of the following messages at stdout:

\Item{Too less parameters} The tool needs at least two parameters. Pass
   the name of the file to generate and at least on FB source file name
   to scan.

\Item{Cannot open `<output>`} The tool isn't able to open the output file
   with write access. Check the directory and the permissions (user
   privileges).

All further exeptions (ie. when a nested source file isn't readable
with the given path information) are handled internaly without user
information.

On non LINUX systems (with fixed stack size) this may result in segment
fault exeptions, when the recursively scanned files are big and / or
they include a lot of nested files. Increase the stack size at compile
time in that case (option -t).


# Background  {#SecBackground}

\CMake has internal dependency checking for a bunch of programming
languages (C, CXX, RC, ASM, Fortran, Java). Unfortunately \FB
isn't supported yet (effective December 2016). This means \CMake does
re-compile a target (object file) when the source code changed (*.bas).
But it doesn't re-compile the target when related code changed, which
may get included by #`INCLUDE` statements (*.bi or nested *.bas files).
Those dependencies have to get managed by an external solution.

The cmakefbc_deps tool is the central component of such an external
solution. It scans one or more \FB source code files and
generates a dependency file to be included in the \CMake project
declarations (files named CMakeList.txt). Each FB source file gets an
entry in the \CMake include file, if it contains nested source files.
This entry lists all nested FB source file names (including absolute
path) in \CMake syntax. Only nested code in the project gets scanned,
and headers in the FB include directory get skipped (ie. like
"dir.bi").

Before the dependency entries the \CMake macro `ADD_FILE_DEPENDENCIES`
gets loaded (if not present) and behind the entries a custom command
gets generated, that updates the dependency file (itself) in case of
any change of one of the nested FB source files. The custom command
also ensures that the file gets removed by a `make clean` command.

Here's an example for a dependency file (output)

~~~{.txt}
# Fbc header dependencies, auto generated by cmakefbc_deps. DO NOT EDIT!

IF(NOT COMMAND ADD_FILE_DEPENDENCIES)
  INCLUDE(AddFileDependencies)
ENDIF()

ADD_FILE_DEPENDENCIES(MyProject.bas /home/user/projects/MyProject.bi;/home/user/projects/File2.bi)

ADD_FILE_DEPENDENCIES(File3.bas /home/user/projects/File2.bas;/home/user/projects/File3.bi)

ADD_CUSTOM_COMMAND(OUTPUT /home/user/projects/CMakeFiles/MyProject_deps.cmake
  COMMAND ${CMAKE_COMMAND} -E cmakefbc_deps /home/user/projects/CMakeFiles/MyProject_deps.cmake MyProject.bas File2.bas File3.bas
  DEPENDS /home/user/projects/MyProject.bi;/home/user/projects/File2.bi;/home/user/projects/File3.bi
  )
~~~

If none of the FB source files contains an #`INCLUDE` file, the
dependency file gets still created, but contains only a comment (the
first line of the above example).

\note The tool doesn't support conditional compiling yet. All nested
      source dependencies get specified, even if the #`INCLUDE`
      statement is in a preprocessor #`IF` block that doesn't get
      compiled on the current system.


# Limits  {#SecLimits}

This external dependency check has some limitations though:

\Item{Conditional compiling} currently the \FbDeps tool doesn't support
  conditional compiling. This means it'll add each file found in a
  #`INCLUDE` statement to the list of dependencies, regardless if the
  code will get compiled or is excluded because of a preprocessor
  statement like #`IF 0`. In everyday work this isn't a big deal since
  mostly just the files for the current subset of the code get changed.
  The philosophy is: better get five dependencies too much than a
  single unchecked.

\Item{Deleting / Moving file names} When a #`INCLUDE` source file
  listed in the dependency file get removed (or renamed), then for the
  next build CMake checks the dependencies and neither finds the source
  file, nor knows a rule on how to build it. This gets reported like
~~~{.txt}
make[2]: *** No rule to build target src/bas/INCLUDE.bi,
  necessary to build »src/bas/CMakeFiles/solar.dir/<otherfilename>.o«.  Finish.
~~~
  In order to avoid this issue you can build the target before you
  delete the source file. Or you can force a new dependency check by
  executing `cmakefbc` before the `make` command.
